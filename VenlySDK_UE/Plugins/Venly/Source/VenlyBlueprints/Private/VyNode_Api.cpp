// Fill out your copyright notice in the Description page of Project Settings.


#include "VyNode_Api.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"

#include "K2NodeUtils.h"
#include "K2Node_CallFunction.h"
#include "K2Node_Event.h"
#include "K2Node_BreakStruct.h"
#include "KismetCompiler.h"
#include "EdGraph/EdGraphSchema.h"

#define LOCTEXT_NAMESPACE "VyNode_Api"
#define CHECK_PIN_CONNECTION(pinResponse) check(!pinResponse.IsFatal())

UClass* UVyNode_Api::GetApiClass() const
{
	ensure(false);
	return UClass::StaticClass();
}

UScriptStruct* UVyNode_Api::GetResponseType() const
{
	ensure(false);
	return nullptr;
}

FName UVyNode_Api::GetSelfFunctionName() const
{
	ensure(false);
	return NAME_Unknown;
}

FName UVyNode_Api::GetRequestFunctionName() const
{
	ensure(false);
	return NAME_Unknown;
}

FName UVyNode_Api::GetOnSuccessDelegateName() const
{
	return OP_ExecuteRequest_OnSuccess;
}

FName UVyNode_Api::GetOnFailedDelegateName() const
{
	return OP_ExecuteRequest_OnFail;
}

FName UVyNode_Api::GetOnCompleteDelegateName() const
{
	ensure(false);
	return NAME_OnCompleteNULL;
}

FName UVyNode_Api::GetApiName() const
{
	ensure(false);
	return NAME_Unknown;
}

FName UVyNode_Api::GetAuthoredName() const
{
	return GetSelfFunctionName();
}

FSlateIcon UVyNode_Api::GetIconAndTint(FLinearColor& OutColor) const
{
	const auto Icon = Super::GetIconAndTint(OutColor);
	OutColor = FLinearColor::FromSRGBColor(FColor::FromHex("#AF48FF"));
	return FSlateIcon(TEXT("Venly"), "VenlyLogoIcon_White");
}

FLinearColor UVyNode_Api::GetNodeTitleColor() const
{
	return FLinearColor::FromSRGBColor(FColor::FromHex("#7927FF"));
}

FName UVyNode_Api::GetCornerIcon() const
{
	//return FName("Venly.VenlyLogo_Purple");
	return FName("Graph.Latent.LatentIcon");
}

void UVyNode_Api::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);

	UClass* ActionKey = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}

FText UVyNode_Api::GetMenuCategory() const
{
	return FText::FromString(FString::Printf(TEXT("Venly | %s"), *GetApiName().ToString()));
}

FText UVyNode_Api::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return FText::FromString(FString::Printf(TEXT("[%s API] %s"), *GetApiName().ToString(), *GetAuthoredName().ToString()));
}

void UVyNode_Api::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();

	//INPUT
	CreateInputPins();

	//OUTPUT
	CreateOutputPins();
}

void UVyNode_Api::CreateInputPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	//Root Execute
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);

	//RequestFunction Pins
	RequestFunctionPinNames.Reset();
	const auto RequestFunction = GetApiClass()->FindFunctionByName(GetRequestFunctionName());

	for(TFieldIterator<FProperty> PropIt(RequestFunction); PropIt && (PropIt->PropertyFlags & CPF_Parm); ++PropIt)
	{
		const FProperty* Param = *PropIt;
		if (!Param || IgnoreInputPinPredicate(this, Param)) continue;

		const auto paramClass = Param->GetClass();
		if(paramClass != nullptr) UE_LOG(LogTemp, Log, TEXT("PARAM(%s) Param Class=%s"),*Param->GetName(), *paramClass->GetName())
		else UE_LOG(LogTemp, Log, TEXT("PARAM(%s) Param Class=NULL"), *Param->GetName())

		UEdGraphPin* Pin = CreatePin(EGPD_Input, NAME_None, Param->GetFName());
		K2Schema->ConvertPropertyToPinType(Param, Pin->PinType);
		K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
		UK2Node_CallFunction::GeneratePinTooltipFromFunction(*Pin, RequestFunction);
		RequestFunctionPinNames.Add(Pin->GetName());
	}
}

void UVyNode_Api::CreateOutputPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, OP_ExecuteRequest_OnComplete);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, OP_ExecuteRequest_OnSuccess);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, OP_ExecuteRequest_OnFail);

	//Response Pins
	ResponseParamPinNames.Reset();
	const auto ResponseType = GetResponseType();

	for (TFieldIterator<FProperty> PropIt(ResponseType); PropIt; ++PropIt)
	{
		const FProperty* Param = *PropIt;
		if (!Param) continue;

		UEdGraphPin* Pin = CreatePin(EGPD_Output, NAME_None, Param->GetFName());
		K2Schema->ConvertPropertyToPinType(Param, Pin->PinType);
		K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
		ResponseParamPinNames.Add(Pin->GetName());
	}
}

void UVyNode_Api::CreateOutputEventConnection(FKismetCompilerContext& CompilerContext, const FName& EventName, const UK2Node_CallFunction* EventCallFunctionNode, const UK2Node_Event* OutputEventNode)
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	const auto RootOnCompletePin = this->FindPin(EventName, EGPD_Output);
	const auto CallRequestFunctionDelegatePin = EventCallFunctionNode->FindPinChecked(EventName, EGPD_Input);
	const auto OnEventNodeExecPin = OutputEventNode->FindPin(UEdGraphSchema_K2::PN_Then);
	const auto OnEventDelegatePin = OutputEventNode->FindPinChecked(OutputEventNode->DelegateOutputName);

	CHECK_PIN_CONNECTION(CompilerContext.MovePinLinksToIntermediate(*RootOnCompletePin, *OnEventNodeExecPin))
	check(K2Schema->TryCreateConnection(OnEventDelegatePin, CallRequestFunctionDelegatePin))
}

bool UVyNode_Api::IgnoreInputPinPredicate(const UEdGraphNode* CustomNode, const FProperty* Param)
{
	// We ignore all delegate types that start with On (OnSuccess, OnError, OnComplete)
	const bool bIsResponseDelegate = Param->GetFName().ToString().StartsWith(TEXT("On"));

	// We ignore all Output parameters because we create these by hand.
	const bool bIsOutputParam = !(!Param->HasAnyPropertyFlags(CPF_OutParm) || Param->HasAnyPropertyFlags(CPF_ReferenceParm));

	//// We also ignore duplicated pin names. This is by design for now --- TODO: We need to resolve name collisions differently as this can easily hide bugs.
	//const UEdGraphPin* EdGraphPin = CustomNode->FindPin(Param->GetFName());

	// Any of these are true, and the param doesn't become an input pin.
	return bIsResponseDelegate || bIsOutputParam; // || EdGraphPin;
}

void UVyNode_Api::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	//Intermediate Nodes
	const UK2Node_CallFunction* CallGetSubsystem = K2NodeUtils::CreateCallFunctionNode(this, CompilerContext, SourceGraph, GetSelfFunctionName(), GetApiClass());
	const UK2Node_CallFunction* CallRequestFunction = K2NodeUtils::CreateCallFunctionNode(this, CompilerContext, SourceGraph, GetRequestFunctionName(), GetApiClass());

	const UK2Node_Event* OnSuccessEventNode = K2NodeUtils::CreateEventNodeForDelegate(this, CompilerContext, SourceGraph, GetOnSuccessDelegateName().ToString());
	const UK2Node_Event* OnFailedEventNode = K2NodeUtils::CreateEventNodeForDelegate(this, CompilerContext, SourceGraph, GetOnFailedDelegateName().ToString());
	const UK2Node_Event* OnCompleteEventNode = K2NodeUtils::CreateEventNodeForDelegate(this, CompilerContext, SourceGraph, GetOnCompleteDelegateName().ToString());

	//Relevant Pins
	const auto RootExecutionPin = K2Schema->FindExecutionPin(*this, EGPD_Input);
	if (RootExecutionPin->LinkedTo.Num() > 1)
		CompilerContext.MessageLog.Error(TEXT("@@ has more than one input. Not supported."), this);

	const auto RootThenPin = this->GetThenPin();

	//Set CallRequestFunction Target
	const auto CallSubsystemReturnPin = CallGetSubsystem->GetReturnValuePin();
	const auto CallRequestSelfPin = K2Schema->FindSelfPin(*CallRequestFunction, EGPD_Input);
	check(K2Schema->TryCreateConnection(CallSubsystemReturnPin, CallRequestSelfPin));

	//Set CallRequestFunction Parameters
	for(const auto InputPinName : RequestFunctionPinNames)
	{
		if(const auto FunctionPin = CallRequestFunction->FindPin(InputPinName))
		{
			const auto RootInputPin = FindPin(InputPinName);
			CHECK_PIN_CONNECTION(CompilerContext.MovePinLinksToIntermediate(*RootInputPin, *FunctionPin));
		}
	}

	//Set CallRequestFunction OnComplete
	CreateOutputEventConnection(CompilerContext, OP_ExecuteRequest_OnComplete, CallRequestFunction, OnCompleteEventNode);
	const auto IntermediateResponsePin = OnCompleteEventNode->FindPin(TEXT("Result"));
	const UK2Node_BreakStruct* BreakResponseNode = K2NodeUtils::CreateBreakStructNode(this, CompilerContext, SourceGraph, K2Schema, GetResponseType(), IntermediateResponsePin);

	//Set Response Parameters
	for (const auto ResponsePinName : ResponseParamPinNames)
	{
		if (const auto FunctionPin = BreakResponseNode->FindPin(ResponsePinName, EGPD_Output))
		{
			const auto RootInputPin = FindPin(ResponsePinName, EGPD_Output);
			CHECK_PIN_CONNECTION(CompilerContext.MovePinLinksToIntermediate(*RootInputPin, *FunctionPin));
		}
	}

	//Set CallRequestFunction OnSuccess
 	CreateOutputEventConnection(CompilerContext, OP_ExecuteRequest_OnSuccess, CallRequestFunction, OnSuccessEventNode);

	//Set CallRequestFunction OnFail
	CreateOutputEventConnection(CompilerContext, OP_ExecuteRequest_OnFail, CallRequestFunction, OnFailedEventNode);

	//Call Request Function & Continue Flow
	const auto CallRequestExecutionPin = CallRequestFunction->GetExecPin();
	const auto CallRequestThenPin = CallRequestFunction->GetThenPin();

	CHECK_PIN_CONNECTION(CompilerContext.MovePinLinksToIntermediate(*RootExecutionPin, *CallRequestExecutionPin));
	CHECK_PIN_CONNECTION(CompilerContext.MovePinLinksToIntermediate(*RootThenPin, *CallRequestThenPin));

	this->BreakAllNodeLinks();
}
#undef LOCTEXT_NAMESPACE
